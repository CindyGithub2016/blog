<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[详解相似图片匹配算法：差异值哈希算法+颜色直方图]]></title>
      <url>%2F2019%2F04%2F12%2F%E8%AF%A6%E8%A7%A3%E7%9B%B8%E4%BC%BC%E5%9B%BE%E7%89%87%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%EF%BC%9A%E5%B7%AE%E5%BC%82%E5%80%BC%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95-%E9%A2%9C%E8%89%B2%E7%9B%B4%E6%96%B9%E5%9B%BE%2F</url>
      <content type="text"><![CDATA[由于最近涉及到匹配相似图片的问题，所以在此记录下解决办法：差异值哈希算法 + 颜色直方图 环境要求：Python cv2库 math库 差异值哈希算法 检索相似图片，第一个想到的就是差异值哈希算法。这个算法的步骤是： 缩小尺寸一般将图片缩放为 8 * 8 的尺寸大小，共64个像素的图片。但是由于64个像素对于我来说，损失的细节太多所以我选择了缩放到 33 * 32 的尺寸大小 彩色图像灰度化由于我们现有的图片是由 RGB 三原色构成，每个像素点是一个由这三个颜色组成的一个 list 。而 RGB 三个颜色中每个颜色值都是用 8 个比特来表示，大小范围是 0 ～ 255(2^8 - 1)，就一共有 256 * 256 * 256 种颜色。并且作为一个像素类似于这样的数值：[253 255 255] 是不利于简单比较的，肉眼看着类似的颜色，但是它的三个颜色分布可能相差很多。所以将它灰度化，用 256 个不同的灰色表示现有的图片。由于现在用一种灰色表示三种颜色，原来每个像素是一个 list 现在就降维成一个数值，数值的大小还是比较容易比较的。 比较像素的灰度值比较图片灰度化的每行相邻像素之间的大小，每行后面像素值大于前面一个像素值那么记为1，如果不大于则记为0 计算哈希值根据上一步得到了由0和1构成的数组合在一起就构成了1024位的整数 对比不同图片的汉明距离对比两个图片生成的整数有多少位不一样。一般汉明距离小于 5 ，两张图片的相似度就很高了。 差异值哈希算法的 Python 代码12345678910111213141516171819202122232425262728293031import cv2# 差异值哈希算法def dhash(image): resize_height, resized_width = 32, 33 # 缩放到(resized_width, resize_height)尺寸的大小 resized_img = cv2.resize(image, (resized_width, resize_height)) # 图片灰度化 grey_resized_img = cv2.cvtColor(resized_img, cv2.COLOR_RGB2GRAY) # 差异值计算 hash_list = [] for row in range(resize_height): for col in range(resized_width - 1): # 每行前一个颜色强度大于后一个，值为1，否则值为0 if grey_resized_img[row, col] &gt; grey_resized_img[row, col + 1]: hash_list.append('1') else: hash_list.append('0') return '' . join(hash_list)# 比较汉明距离def hamming_distance(dhash1, dhash2): return bin(int(dhash1, base = 2) ^ int(dhash2, base = 2)).count('1')# 读取图片内容img1 = cv2.imread(img1_path)# 读取图片内容img2 = cv2.imread(img2_path)if hamming_distance(dhash(img1), dhash(img2)) &lt;= 5: print('相似图片') 颜色直方图 由于差异值哈希失去了太多的细节，适合比较原图或者缩略图。所以我再加上颜色直方图的比较计算图片间的接近程度，用以排除部分像素的微小差异。 缩小尺寸一般将图片缩放为 8 * 8 的尺寸大小，共64个像素的图片。但是由于64个像素对于我来说，损失的细节太多所以我选择了缩放到 32 * 32 的尺寸大小 降低位深原来 RGB 每个颜色都有 256 种变化，现在做一个映射，将原来的 256 分为 8(3个比特表示) 个颜色区间。类似旧的 0 - 31 对应新的颜色 0，以达到降低计算的效果 计算像素值由于降低了位深，图片颜色值变小。每个颜色值不大于8（0 - 7），然后我们给三元素不同的权重，分别为 8 * 8，8，1 作为数组的 key，用以统计每个颜色的像素出现次数，并且不会出现不同颜色统计到了同一个 key 值下的目的。 计算相似度计算出像素值后得到，我们得到了以不同颜色的数值为 key，出现次数为 value 的数组。这时候我们可以使用用余弦相似度去计算相同颜色出现次数的相似度，越是相似的像素最后值越接近于1。截图来自于WiKi 颜色直方图的 Python 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import cv2from math import sqrt# 颜色映射def bgr_mapping(img_val): # 将bgr颜色分成8个区间做映射 if img_val &gt;= 0 and img_val &lt;= 31: return 0 if img_val &gt;= 32 and img_val &lt;= 63: return 1 if img_val &gt;= 64 and img_val &lt;= 95: return 2 if img_val &gt;= 96 and img_val &lt;= 127: return 3 if img_val &gt;= 128 and img_val &lt;= 159: return 4 if img_val &gt;= 160 and img_val &lt;= 191: return 5 if img_val &gt;= 192 and img_val &lt;= 223: return 6 if img_val &gt;= 224: return 7# 颜色直方图的数值计算def calc_bgr_hist(image): if not image.size: return False hist = &#123;&#125; # 缩放尺寸减小计算量 image = cv2.resize(image, (32, 32)) for bgr_list in image: for bgr in bgr_list: # 颜色按照顺序映射 maped_b = bgr_mapping(bgr[0]) maped_g = bgr_mapping(bgr[1]) maped_r = bgr_mapping(bgr[2]) # 计算像素值 index = maped_b * 8 * 8 + maped_g * 8 + maped_r hist[index] = hist.get(index, 0) + 1 return hist# 计算两张图片的相似度def compare_similar_hist(h1, h2): if not h1 or not h2: return False sum1, sum2, sum_mixd = 0, 0, 0 # 像素值key的最大数不超过512，直接循环到512，遍历取出每个像素值 for i in range(512): # 计算出现相同像素值次数的平方和 sum1 = sum1 + (h1.get(i, 0) * h1.get(i, 0)) sum2 = sum2 + (h2.get(i, 0) * h2.get(i, 0)) # 计算两个图片次数乘积的和 sum_mixd = sum_mixd + (h1.get(i, 0) * h2.get(i, 0)) # 按照余弦相似性定理计算相似度 return sum_mixd / (sqrt(sum1) * sqrt(sum2))# 读取图片内容img1 = cv2.imread(img1_path)# 读取图片内容img2 = cv2.imread(img2_path)if compare_similar_hist(calc_bgr_hist(img1), calc_bgr_hist(img2)) &lt; 0.9999: print('相似图片') 总结 总的来说：差异值哈希算法 + 颜色直方图 解决了我的相似图片匹配问题。 参考资料 相似图片搜索的原理一 相似图片搜索的原理二 （完） 本文作者：Cindy 本文标题：Create Custom Demain Name Of Github Pages 版权声明：自由转载-非商用-非衍生-保持署名（创意共享4.0许可证）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PHP 包与扩展的管理工具Pear、Composer 与 Pecl]]></title>
      <url>%2F2018%2F05%2F04%2FPHP%E5%8C%85%E4%B8%8E%E6%89%A9%E5%B1%95%E7%9A%84%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7Pear%E3%80%81Composer%E4%B8%8EPecl%2F</url>
      <content type="text"><![CDATA[PHP社区提供了几个管理扩展和包的工具包括Pecl、Pear、Pear2和Composer。在不了解的情况下去使用这些工具必然会出现困惑，所以下面就简单介绍下这几个管理工具。 一、简介下面简要介绍 Pear、Pear package、Pear installer、Pear2、Pyrus、Composer、Pecl。 PearPear 是 PHP 扩展与应用库（the PHP Extension and Application Repository）的缩写，是一个 PHP 扩展及应用的一个代码仓库。Pear 仓库代码是以包（package）分区，每一个 Pear package 都是一个独立的项目有着自己独立的开发团队、版本控制、文档和其他包的依赖关系信息。Pear package 以 phar、tar 或 zip 发布。 Pear 的包管理器是Pear installer，用来浏览并搜索 Pear package、查看最新发行版、下载 Pear package。 Pear2Pear2 是下一代的 Pear 代码仓库，在使用性、速度、安全上都有改进。Pear2 的包管理器 Pyrus 是下一代的 Pear installer，使用 PHP 编写，以 phar 格式发布。 ComposerComposer 是 PHP 中的应用程序级的包依赖管理器。用来管理（安装/更新）你项目中申明的依赖库。Composer 的包信息存储库是 Packagist。 PeclPecl 是 PHP 扩展社区仓库（The PHP Extension Community Library）的缩写，Pecl 扩展库的包（package）是使用 C、C++ 编写的动态链接库扩展，在编译安装后通过 php.ini 加载，随 PHP 进程被装入内存。 二、发布时间轴 三、Mac 安装与使用PearPear 安装主要是安装 Pear installer 和 Pyrus 这两个包管理器，然后通过包管理器安装其他 Pear package。 （1）Pear installer如果你安装的是PHP (&gt; 4.3.0)，并且编译时并未使用“./configure flag –without-pear”选项，那么 Pear installer 的安装已集成在系统里。但如果你安装的 PHP(&lt; 4.3.0)，那么你就需要手动安装 Pear installer。 下载 go-pear.phar 文件 1$ curl -O https://pear.php.net/go-pear.phar 全局安装 Pear 命令和安装一些 Pear 包 1$ sudo php -d detect_unicode=0 go-pear.phar 配置 Pear 进行安装 1) 更改 Installation Base 位置 输入1，然后按下 Enter 输入 /usr/local/pear，然后按下 Enter 2) 更改 Binaries directory 位置 输入4，然后按下 Enter 输入 /usr/local/bin，然后按下 Enter 3）再按下 Enter 一次，让其默认 4）安装完成 查看版本 1$ pear -V 安装 Pear package 名称为 mypear 1$ sudo pear install mypear 使用安装包 mypear 因为 Pear 库中的包都是由 PHP 编写的的，所以使用只需要在代码层手动 require/include 引入文件 （2）Pyrus Pyrus 正常工作需要 phar、simplexml、libxml2、spl 和 pcre 扩展，在 PHP (&gt; 5.3.0) 中是默认开启的 下载文件 pyrus.phar 1$ wget http://pear2.php.net/pyrus.phar 第一次使用先运行php pyrus.phar 1234$ php pyrus.phar$ 输入 yes，然后按下Enter$ 输入你安装包存放的位置 /Users/my-project，然后按下Enter$ 安装完成 查看版本 1$ php pyrus.phar --version 安装 Pear package 名称为 mypear 1$ php pyrus.phar install mypear 使用安装包 mypear （1）因为 Pear 库中的包都是由 PHP 编写的，所以使用只需要在代码层手动 require/include 引入文件，但require_once 不被允许 （2）Pyrus 可以使用自带的 autoloader 自动引入 PeclPecl 可以通过 Pear 的 Package Manager 的安装管理方式，来进行下载和安装。 安装成功 而使用 Pecl 扩展库必须要经过下载扩展库、编译、安装、然后加载。而加载 下载 Pecl 扩展库 extname （1）通过 Pear 下载 Pecl 扩展库 1$ pecl install extname （2）官网下载：http://pecl.php.net/ （3）SVN 下载，大多数 Pecl 扩展库也在 SVN 中 1$ svn checkout http://svn.php.net/repository/pecl/extname/trunk extname 编译、安装 （1）通过 Pear 下载编译共享 Pecl 扩展库 extname 1$ pecl install extname 这个过程下载 extname 的源代码，编译之，并将创建 extname.so 放置于 PHP 的扩展库目录中。 （2）通过 phpize 编译共享 Pecl 扩展库 extname 1234567891011121314151. 下载 extname 源代码2. 进入 extname 目录 $ cd extname3. 准备 PHP 扩展库的编译环境 $ phpize4. 编译 $ ./configure $ make $ make install 成功的安装并将创建 extname.so 并放置于 PHP 的扩展库目录中。 加载 （1）通过 php.ini 加载 extname.so 1231）：Windows上是加载扩展的动态链接库后缀是“.dll”，在 Unix 或 Linux 上是“.so” 2）：修改 php.ini，扩展已经在 php.ini 里。如果有 extension=extname.so 那么去掉前面“;”，或者直接添加 extension=extname.so 按照扩展文档方式启用扩展 Composer Composer 需要 PHP（&gt; 5.3.2） 下载 composer.phar 到当前目录 1$ curl -sS https://getcomposer.org/installer | php 运行 Composer 1$ php composer.phar 查看版本 1$ php composer.phar -V 下载安装包 package 1$ php composer.phar install package 使用安装包 （1）使用 autoloader 自动加载因为 Composer 生成了一个 vendor/autoload.php 文件，可以直接 require/include 引入这个文件。 四、比较扩展与包 PHP的扩展（extension）这里应称为“模块（module）”是 C、C++ 编写的功能合集，而包（package）是 PHP 编写的功能合集 PHP的包（package）以动态链接 .dll、.so 形式加载，而包则是直接引入通过 require/include 方式加載 所以，Pecl 和 Pear 是互为补充，管理者扩展与包。 Pear installer 与 ComposerComposer 虽然比 Pear 晚出现10多年，但就像 Pear 官方文档里面 “If you read tweets and forums you’ll get that impression that nobody uses PEAR anymore, and everyone is using composer now.” 说的，现在所有人都是在使用 Composer。因为 Pear installer 能的 Composer 都能做，并且能做的更好，但 Composer 能做的，Pear installer 却不一定能做。举两个例子： Pear installer 作为系统级软件包，通常需要 root 或管理员权限。并且对于一台机器上多个项目很难使用不同版本库，但 Composer 只需你在项目根目录下修改 composer.json 文件后 update 就可以对该项目的依赖库进行版本的修改。 Pear installer 依赖关系模糊，但 Composer 有申明依赖关系的文件 composer.json（位于项目根目录下），并且还有 composer.lock（位于项目根目录下）文件类似锁文件会使任何人建立项目都将下载与指定版本完全相同的依赖，从而减轻潜在的错误对部署的影响。 五、使用 Composer 安装 Pear package既然 Pear installer 已经完全被 Composer 取代了，那么 Pear 库里面的一些 Pear package 我们是否也可以使用 Composer 包管理器来安装？毕竟 Pear 库有 Packagist（Composer 的包信息存储库） 没有的扩展包。所以下面介绍如何使用 Composer 来安装 Pear package。 修改 Composer 获取包的渠道为“pear”，require 下载该渠道下的扩展包，并将 pear-pear2 作为包前缀避免冲突 { &quot;repositories&quot;: [ { &quot;type&quot;: &quot;pear&quot;, &quot;url&quot;: &quot;https://pear2.php.net&quot; } ], &quot;require&quot;: { &quot;pear-pear2.php.net/PEAR2_Text_Markdown&quot;: &quot;*&quot;, &quot;pear-pear2/PEAR2_HTTP_Request&quot;: &quot;*&quot; } } 完成后，代码位于项目目录 vendor 文件夹中。应用时直接使用 autoloader 自动加载 六、总结如果是包使用 Composer 安装使用，如果是涉及底层扩展则使用 Pecl（也可以使用其他编译安装方式） 安装。 七、参考资料 PEAR简介:用PEAR来写你的下一个php程序 基于 PHP5 面向对象特性的 PECL 扩展 Perl 与 PDO 编程 PECL 扩展库安装 What is the difference between PEAR and PEAR2? PHP7 學習筆記 （完） 本文作者：Cindy 本文标题：PHP 包与扩展的管理工具Pear、Composer 与 Pecl 版权声明：自由转载-非商用-非衍生-保持署名（创意共享4.0许可证）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RabbitMQ使用]]></title>
      <url>%2F2017%2F11%2F25%2FRabbitMQ%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[一、RabbitMQ的定义RabbitMQ是使用erlang语言开发的开源消息队列系统，完整的实现了AMPQ（高级抽象层消息通信协议）。 二、Mac下RabbitMQ安装 使用Homebrew安装 1$ brew install rabbitmq 修改 ~/.bash_profile 配置环境变量： 12# RabbitMQ Configexport PATH=$PATH:/usr/local/sbin 重启配置 1$ source ~/.bash_profile 启动mq服务（后台启动为rabbitmq-server -detached） 1$ rabbitmq-server 登录管理界面 http://127.0.0.1:15672 账号密码为：guest 三、客户端RabbitMQ官方提供了三种PHP可用的扩展：php-amqp，php-rabbit，php-amqplib php-amqplib 安装php的客户端现在常用的是php-amqplib （1）直接拉取github上面的代码1$ git clone https://github.com/php-amqplib/php-amqplib.git （2）composer安装（官网提供） 将composer.json文件添加到您的项目中 { “require”：{ “php-amqplib / php-amqplib”：“&gt; = 2.6.1” } } 下载依赖 1$ composer install 四、概念 Virtual vhostsvirtual vhosts是一个命名空间，可以存在多个exchange和queue。实现了环境（用户，用户组，exchange，queue）隔离，是权限控制的最小粒度。默认的virtual host为/。 Exchange(交换机)接受producer发送的消息，并根据binding绑定规则转发到对应的队列。默认是无名交换使用空字符串标识。exchange type(交换机类型)包含四种类型：direct，topic，headers，fanout （1）direct转发消息到routigKey指定的队列 （2）topic类似于direct类型，只不过routigKey为一个句点号“.”分隔的字符串 可以替代一个字。 ＃ 可以替换零个或多个单词。 （3）headers根据发送的消息内容中的headers属性进行匹配。 （4）fanout将所有收到的消息广播到所有已知的队列。 Queue(消息队列)queue是mq内部对象，用于存储未被customer消费的消息。相同属性的queue可以重复定义，每个消息都会被投入到一个或多个队列。 Binding(绑定)binding是将exchange和queue按照路由规则绑定起来。可以理解为binding是exchange和queue之间的关系 Connection（连接）消息tcp连接 Channel(信道)每个connection里，可建立多个channel，每个channel代表一个会话任务。做到尽量共用connection 五、RabbitMQ使用示例 send.php: 12345678910111213141516171819202122require_once __DIR__ . '/vendor/autoload.php';use PhpAmqpLib\Connection\AMQPStreamConnection;use PhpAmqpLib\Message\AMQPMessage;// 创建连接$connection = new AMQPStreamConnection('localhost', 5672, 'guest', 'guest');// 创建channel，多个channel可以共用连接$channel = $connection-&gt;channel();// 创建交换机以及队列（如果已经存在，不需要重新再次创建并且绑定）// 创建直连的交换机$channel-&gt;exchange_declare('direct_logs', 'direct', false, false, false);// 创建队列$channel-&gt;queue_declare('hello', false, false, false, false);// 交换机跟队列的绑定，$channel-&gt;queue_bind('hello', 'direct_logs', 'routigKey');// 设置消息bady传送字符串logs(消息只能为字符串，建议消息均json格式)$msg = new AMQPMessage('logs');// 发送数据到对应的交换机direct_logs并设置对应的routigKey$channel-&gt;basic_publish($msg, 'direct_logs', 'routigKey'); receive.php: 1234567891011121314151617181920212223242526272829require_once __DIR__ . '/vendor/autoload.php';use PhpAmqpLib\Connection\AMQPStreamConnection;// 创建连接$connection = new AMQPStreamConnection('localhost', 5672, 'guest', 'guest');// 创建channel，多个channel可以共用连接$channel = $connection-&gt;channel();// 可能会在数据发布之前启动消费者，所以我们要确保队列存在，然后再尝试从中消费消息。// 创建直连的交换机$channel-&gt;exchange_declare('direct_logs', 'direct', false, false, false);// 创建队列$channel-&gt;queue_declare('hello', false, false, false, false);// 交换机跟队列的绑定，$channel-&gt;queue_bind('hello', 'direct_logs', 'routigKey');// 回调函数$callback = function ($msg) &#123; echo $msg-&gt;body;&#125;;// 启动队列消费者$channel-&gt;basic_consume('hello3', '', false, true, false, false, $callback);// 判断是否存在回调函数while(count($channel-&gt;callbacks)) &#123; // 此处为执行回调函数 $channel-&gt;wait();&#125; 六、RabbitMQ备注 非持久化会导致，队列重启，数据丢失 exchange持久化，在声明durable时参数指定为true queue持久化，在声明durable时参数指定true 消息持久化，实例化AMQPMessage类时指定delivery_mode为2 exchange和queue是否持久化需要一致才能绑定 消费者设置手动ack，在声明no_ack参数时指定false 队列消息异常需要将消息删除并再次发送同样的消息置于末尾并手动记录日志 （完） 本文作者：Cindy 本文标题：Create Custom Demain Name Of Github Pages 版权声明：自由转载-非商用-非衍生-保持署名（创意共享4.0许可证）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mysql的索引详解]]></title>
      <url>%2F2017%2F03%2F26%2FMysql%E7%9A%84%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[一、索引的定义索引(Index)是帮助Mysql高效获取数据的数据结构，即索引是数据结构。也就是说这些数据结构(索引)满足特定的查找算法，并且指向了数据来达到帮助Mysql高效获取数据的目的。 二、常用的查找算法Mysql常用的查找算法是B树和B+树 三、B+树作为索引结构索引很大，如下面一节提到的都是以索引文件形式存储在磁盘上。但是访问磁盘，我们都知道磁盘的IO操作，是机械运动，相对于内存存取要高几个量级。所以就有了将磁盘数据预读到内存中，预读的长度一般为页的整数倍。 根据局部性原理：在一段时间内，整个程序的执行所访问的存储空间局限于某个区域。所以设计者巧妙利用了局部性预读预读原理，将一个节点的大小设为等于一个页。因为根节点是常驻内存的，在根节点向下读取节点的时候，会触发一个缺页异常。此时，一次磁盘IO操作就会载入这个节点到内存。所以对于高度相对较大的二叉树就相比B树和B+树就显得不适合。 而B+树是B树的变种，区别在于B+树节点不存储数据，但是B树节点会存储数据。所以在查找的时候B树检索有可能在非叶子结点结束，但是B+树是只会在叶子节点结束。但是B+树叶节点两两相连可大大增加区间访问性，可使用在范围查询等，而B-树每个节点和数据在一起，则无法区间查找。而且最重要的在一次磁盘IO中，B树的每个节点都带有对应的数据，增加了节点的大小。而磁盘IO一次读出的数据量大小是固定的，单个数据变大，每次读出的就少，那么IO次数就会增多。所以从这点来看，B+树相对B-树磁盘IO次数会少。 四、索引的存储数据库必须要有索引，没有索引则检测就会变成顺序查找，时间的复杂度是O(n),在数据量很大的时候无疑是很恐怖的。在Mysql中索引是在存储引擎中实现的(上节有提到)，而不同存储引擎会使用不同索引。下面主要介绍Mysql中的InnoDB和MyISAM两种引擎。 （1）InnoDB引擎索引的存储InnoDB引擎使用B+树作为索引结构。上节有提到InnoDB引擎的索引跟数据都是保存在同一个文件中。再具体点，对于InnoDB引擎的B+树主键索引结构，非叶子节点存储的是表的主键，叶子节点存储的是表的行数据。如图所示： 查询where id=37,其中id为主键，这时候创建的主键索引如上图，这样的条件查找主键，只需要按照B+树的检索算法(红线所示)就可以找到对应的叶子节点，然后获取到行数据。而如果查询的条件为where name=&#39;Cindy&#39;,这时候开始查询的并不是主键而是辅助键。如图所示： 这是辅助键索引B+树，是另外一棵B+树。这时候就有主键索引B+树和辅助键索引B+树，查询的时候分两步： 在辅助索引B+树中检索Cindy(红线所示), 到达其叶子节点获取到对应的主键 获取到主键之后，在主键索引B+树中检索37，到达其叶子节点获取到对应的行数据 意思就是检索完辅助索引B+树后，再检索主键索引B+树。所以InnoDB表要求必须要有主键(MyISAM可以没有)，并且最好是自增主键。如果没有设定主键或者非空唯一索引，那么MySQL自动为InnoDB表生成不可见6个字节的字段作为主键。 （2）MyISAM引擎索引的存储MyISAM引擎也是使用B+树作为索引结构，只不过跟InnoDB引擎不同的地方在于，它的索引跟数据保存在不同文件中(上节有提到)。所以MyISAM引擎的主键索引B+树的叶子节点不再是保存的行数据，而是指向行数据的地址。不一样的还有辅助键索引B+树，它的叶子节点也是指向行数据的地址。对于行数据来说，两个键(主键和辅助键)无任何差别，都是直接通过B+树检索到地址。 也就是说MyISAM引擎通过辅助键查询的时候不需要再次访问主键索引B+树。像InnoDB引擎这样B+树的索引结构，行数据的物理存储顺序就是索引顺序的存储方式就是聚簇索引，像MyISAM引擎这样B+树的索引结构，行数据的物理存储顺序跟索引顺序无关的存储方式就是非聚簇索引，就有人会问，那么InnoDB索引存储的优势在哪？明明每次使用辅助索引检索都要经过两次B+树查找。 五、查询比较 上一节有提到MyISAM适合select密集的表。在select密集的表，如果是根据主键查询，那么InnoDB引擎索引存储方式只需要检索主键索引树就可以直接拿到行数据，但是MyISAM只会拿到地址，还必须再次查找。但是如果不是主键查询，InnoDB方式会比MyISAM方式多检索一颗B+树，所以这就是为什么MyISAM适合select密集的表。 当出现行移动或者数据页分裂时辅助索引的维护工作，InnoDB方式只需要更新主键索引B+树，但是MyISAM方式则是需要更新树的地址。 六、聚簇索引定义聚簇索引: 聚簇索引的顺序就是数据的物理存储顺序的存储方式。 七、非聚簇索引定义非聚簇索引: 索引顺序与数据物理排列顺序无关的存储方式 八、参考文献MySQL的InnoDB索引原理详解 （完） 本文作者：Cindy 本文标题：Create Custom Demain Name Of Github Pages 版权声明：自由转载-非商用-非衍生-保持署名（创意共享4.0许可证）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mysql的引擎详解]]></title>
      <url>%2F2017%2F03%2F25%2FMysql%E7%9A%84%E5%BC%95%E6%93%8E%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[一、数据库的定义我们说的Mysql数据库是数据库管理系统。其中包含了数据的存储，查询，以及更新数据库中存储数据的的功能等。 二、存储引擎的定义关系型数据库是以表的形式存储在文件或者内存中。而存储引擎可以称为操作，存储这些表的类型。 三、支持的存储引擎1$ mysql&gt; show engines; 四、详解InnoDB引擎InnoDB引擎是一个常用的事务型存储引擎。提供了事务，行级锁机制和外键约束的功能。适用于以下场合： 事务 外键约束 崩溃后的灾难恢复 高并发，更新密集型的表 不支持全文索引 在RUN001数据库中创建MYTABLE，MYTABLE1两张表使用InnoDB引擎，在RUN001文件夹下会生成多个文件： .frm结尾的文件是表结构文件 [tips: 这个文件与数据库引擎无关，任何存储引擎都会去生产这个与表名同名的文件。可以用来在数据库奔溃时恢复表结构] .ibd结尾的文件这个是单表空间文件(独立表空间)，也就是每个表使用一个表空间文件。存储该表的相关的数据，索引。 [tips：如果是共享表空间，表数据和索引会保存在默认表空间文件是ibdata1(默认)中，这时候是所有表共用ibdata1(一个或者多个)文件。而bdata1文件不会在RUN001文件夹下］ .opt结尾的文件是存储改数据库下的所有表的字符集和排序规则 五、详解MyISAM引擎MyISAM引擎则是不支持事务，行级锁和外键约束的。并且是强调性能，执行速度的引擎。适用于以下场合： 新增密集的表，在表有读取查询的同时，支持往表中插入新纪录 筛选select密集的表 支持全文索引 不支持行锁，读取时对需要读到的所有表加锁，写入时则对表加排它锁 在RUN001数据库中创建MYTABLE2，MYTABLE3两张表使用InnoDB引擎，在RUN001文件夹下每张表都会生成三个文件在数据库： .frm结尾的文件是表结构文件.MYD结尾的文件是存储数据文件.MYI结尾的文件是存储表的索引文件 最后总结一下，InnoDB适合inset和update密集型的表，MyISAM适合select密集的表 提示：最后的归类总结跟引擎使用的索引有关，下节会讲到。 六、使用示例1$ create table MYTABLE2 (name VARCHAR(20), sex CHAR(1))ENGINE=MyISAM; （完） 本文作者：Cindy 本文标题：Create Custom Demain Name Of Github Pages 版权声明：自由转载-非商用-非衍生-保持署名（创意共享4.0许可证）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mysql的数据类型]]></title>
      <url>%2F2017%2F03%2F25%2FMysql%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
      <content type="text"><![CDATA[Mysql多种类型可以分为三类：数值、日期/时间和字符串(字符)类型。 一、数值类型整数: tinyint、smallint、mediumint、int、bigint浮点数: float、double、real、decimal 二、日期和时间类型date、time、datetime、timestamp、year 三、字符串类型字符串: char、varchar文本: tinytext、text、mediumtext、longtext二进制(可用来存储图片、音乐等): tinyblob、blob、mediumblob、longblob （完） 本文作者：Cindy 本文标题：Create Custom Demain Name Of Github Pages 版权声明：自由转载-非商用-非衍生-保持署名（创意共享4.0许可证）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Mac下Mysql的安装与卸载]]></title>
      <url>%2F2017%2F03%2F24%2FMac%E4%B8%8BMysql%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD%2F</url>
      <content type="text"><![CDATA[用Homebrew安装Mysql,首先需要安装Homebrew。 一、安装Mysql1$ brew install mysql 二、运行测试1$ mysql.server start 显示： Starting MySQL . SUCCESS! 三、登录默认情况下，Mysql用户root没有密码。1$ mysql -uroot 修改密码：1$ mysqladmin -u root password 'new-password' 四、卸载mysql12$ brew remove mysql$ brew cleanup 如果设置了开机启动：12$ launchctl unload -w ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist$ rm -Rf ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist （完） 本文作者：Cindy 本文标题：Create Custom Demain Name Of Github Pages 版权声明：自由转载-非商用-非衍生-保持署名（创意共享4.0许可证）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Create Custom Demain Name Of Github Pages]]></title>
      <url>%2F2017%2F03%2F18%2Fcustom-demain-name-of-github-pages%2F</url>
      <content type="text"><![CDATA[用自定义网址去替换username.github.io.，因为自己有这样的需求，但是在网上看到的大多都不适用，所以整理下正确的三步方法。 在Gandi购买的.me域名username.me，托管在Github Pages的域名是username.github.io。 一、解析username.me域名到Github pages的服务器在Gandi的管理界面操作。打开域名详情： 点击正在使用的版本。因为Gandi不允许你直接编辑区域文件，所以你必须创建副本，清空副本内容并去新增一条记录： (1) 新增类型A,代表服务器的IP指向。那么底下的值就应该填GitHub提供的地址IP：192.30.252.153，而主机纪录选择@是表示username.me的解析。TTL是指域名解析的生命周期，对于固定IP的来说建议设置3600s。 (2) 新增一个跟(1)类似的纪录，只是将IP替换为192.30.252.154。 二、多个域名映射新增类型CNAME,别名解析。那么底下的值就应该填你的Github pages的域名username.github.io. ,主机纪录选择www。TTL一样设置3600s。 最后点击使用此版本，并且确认使用此区域的域名是username.me。（DNS需要几个小时才能生效） 三、隐藏username.github.io域名 在根目录下面创建一个名为CNAME的文本文件， 里面内容为你的.me域名：1$ vi CNAME 或者直接在Github项目的setting中直接设置custom domain。 接着访问你的username.github.io的网址，会发现301重定向到了username.me 总的就做完了。 最后提示下，Github pages中的CNAME的文本文件起到了两个作用：（1）因为username.me解析的IP是Github pages对外提供的公用IP，只是靠IP无法定位到具体page库的所以CNAME里面的域名就起到了定位的作用，所以CNAME里面无对应的域名是会报404的错误的。（2）那就是我说的重定向了，username.github.io域名被隐藏，转到username.me域名了 （完） 本文作者：Cindy 本文标题：Create Custom Demain Name Of Github Pages 版权声明：自由转载-非商用-非衍生-保持署名（创意共享4.0许可证）]]></content>
    </entry>

    
  
  
</search>
