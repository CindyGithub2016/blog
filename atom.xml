<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cindy&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cindygithub2016.github.io/blog/"/>
  <updated>2018-05-04T04:35:45.175Z</updated>
  <id>https://cindygithub2016.github.io/blog/</id>
  
  <author>
    <name>Cindy</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PHP 包与扩展的管理工具Pear、Composer 与 Pecl</title>
    <link href="https://cindygithub2016.github.io/blog/2018/05/04/PHP%E5%8C%85%E4%B8%8E%E6%89%A9%E5%B1%95%E7%9A%84%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7Pear%E3%80%81Composer%E4%B8%8EPecl/"/>
    <id>https://cindygithub2016.github.io/blog/2018/05/04/PHP包与扩展的管理工具Pear、Composer与Pecl/</id>
    <published>2018-05-04T01:52:27.000Z</published>
    <updated>2018-05-04T04:35:45.175Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>PHP社区提供了几个管理扩展和包的工具包括<a href="http://pecl.php.net/" target="_blank" rel="external">Pecl</a>、<a href="http://pear.php.net/" target="_blank" rel="external">Pear</a>、<a href="https://pear2.php.net/" target="_blank" rel="external">Pear2</a>和<a href="https://getcomposer.org/" target="_blank" rel="external">Composer</a>。在不了解的情况下去使用这些工具必然会出现困惑，所以下面就简单介绍下这几个管理工具。</p>
</blockquote>
<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>下面简要介绍 Pear、Pear package、Pear installer、Pear2、Pyrus、Composer、Pecl 定义。</p>
<h4 id="Pear"><a href="#Pear" class="headerlink" title="Pear"></a>Pear</h4><p>Pear 是 PHP 扩展与应用库（the PHP Extension and Application Repository）的缩写，是一个 PHP 扩展及应用的一个代码仓库。Pear 仓库代码是以包（package）分区，每一个<code>Pear package</code>都是一个独立的项目有着自己独立的开发团队、版本控制、文档和其他包的依赖关系信息。Pear package 是以 phar、tar 或 zip 发布的，而为了去浏览并搜索 Pear package、查看最新发行版、下载 Pear package 就有包管理器<code>Pear installer</code>。</p>
<h4 id="Pear2"><a href="#Pear2" class="headerlink" title="Pear2"></a>Pear2</h4><p>Pear2 是下一代的 Pear 代码仓库，在使用性、速度、安全上都有改进。而 Pyrus 是下一代的 Pear installer，是使用 PHP 编写的，然后压缩成 phar 格式。</p>
<h4 id="Composer"><a href="#Composer" class="headerlink" title="Composer"></a>Composer</h4><p>Composer 是 PHP 中的应用程序级的包依赖管理器。用于管理（安装/更新）你项目中申明的依赖库。而 Composer 的包信息存储库使 Packagist。</p>
<h4 id="Pecl"><a href="#Pecl" class="headerlink" title="Pecl"></a>Pecl</h4><p>Pecl 是 PHP 扩展库仓库（The PHP Extension Community Library）的缩写，Pecl 扩展库同样是以包（package）分区，但是这里的包指的是使用 C、C++ 编写的动态链接库扩展，在编译安装后通过 php.ini 加载，随 PHP 进程被装入内存。</p>
<h3 id="二、发布时间轴"><a href="#二、发布时间轴" class="headerlink" title="二、发布时间轴"></a>二、发布时间轴</h3><p><img src="/uploads/PHP包与扩展的管理工具Pear、Composer与Pecl/1.png" alt="图片描述"></p>
<h3 id="三、Mac-安装与使用"><a href="#三、Mac-安装与使用" class="headerlink" title="三、Mac 安装与使用"></a>三、Mac 安装与使用</h3><h4 id="Pear-1"><a href="#Pear-1" class="headerlink" title="Pear"></a>Pear</h4><p>Pear 安装主要是安装 Pear installer 和 Pyrus 这两个包管理器，然后通过包管理器安装其他 Pear package。</p>
<h5 id="（1）Pear-installer"><a href="#（1）Pear-installer" class="headerlink" title="（1）Pear installer"></a>（1）Pear installer</h5><p>如果你安装的是PHP (&gt; 4.3.0)，并且编译时并未使用“./configure flag –without-pear”选项，那么 Pear installer 的安装已集成在系统里。但如果你安装的 PHP(&lt; 4.3.0)，那么你就需要手动安装 Pear installer。</p>
<ol>
<li><p>下载 go-pear.phar 文件</p>
<pre><code>$ curl -O https://pear.php.net/go-pear.phar
</code></pre></li>
<li><p>全局安装 Pear 命令和安装一些 Pear 包</p>
<pre><code>$ sudo php -d detect_unicode=0 go-pear.phar
</code></pre></li>
<li><p>配置 Pear 进行安装</p>
<pre><code>$ 输入1，然后按下 Enter
$ 输入 /usr/local/pear，然后按下 Enter
$ 输入4，然后按下 Enter
$ 输入 /usr/local/bin，然后按下 Enter
$ 再按下 Enter 一次，让其默认
$ 安装完成
</code></pre></li>
<li><p>查看版本</p>
<pre><code>$ pear -V
</code></pre></li>
<li><p>安装 Pear package 名称为 mypear</p>
<pre><code>$ sudo pear install mypear
</code></pre></li>
<li><p>使用安装包 mypear</p>
</li>
</ol>
<p>因为 Pear 库中的包都是由 PHP 编写的的，所以使用只需要在代码层手动 require/include 引入文件</p>
<h5 id="（2）Pyrus"><a href="#（2）Pyrus" class="headerlink" title="（2）Pyrus"></a>（2）Pyrus</h5><ol>
<li><p>Pyrus 正常工作需要 phar、simplexml、libxml2、spl 和 pcre 扩展，在 PHP (&gt; 5.3.0) 中是默认开启的</p>
</li>
<li><p>下载文件 pyrus.phar</p>
<pre><code>$ wget http://pear2.php.net/pyrus.phar
</code></pre></li>
<li><p>第一次使用先运行<code>php pyrus.phar</code></p>
<pre><code>$ php pyrus.phar
$ 输入 yes，然后按下Enter
$ 输入你安装包存放的位置 /Users/my-project，然后按下Enter
$ 安装完成
</code></pre></li>
<li><p>查看版本</p>
<pre><code>$ php pyrus.phar --version
</code></pre></li>
<li><p>安装 Pear package 名称为 mypear</p>
<pre><code>$ php pyrus.phar install mypear
</code></pre></li>
<li><p>使用安装包 mypear</p>
<pre><code>（1）因为 Pear 库中的包都是由 PHP 编写的，所以使用只需要在代码层手动 require/include 引入文件，但require_once 不被允许

（2）Pyrus 可以使用自带的 autoloader 自动引入
</code></pre></li>
</ol>
<h4 id="Pecl-1"><a href="#Pecl-1" class="headerlink" title="Pecl"></a>Pecl</h4><p>Pecl 可以通过 Pear 的 Package Manager 的安装管理方式，来进行下载和安装。</p>
<p><img src="/uploads/PHP包与扩展的管理工具Pear、Composer与Pecl/2.png" alt="图片描述"></p>
<p>安装成功</p>
<p>而使用 Pecl 扩展库必须要经过下载扩展库、编译、安装、然后加载。而加载</p>
<ol>
<li><p>下载 Pecl 扩展库 extname</p>
<p>（1）通过 Pear 下载 Pecl 扩展库</p>
<pre><code>$ pecl install extname
</code></pre><p>（2）官网下载：<a href="http://pecl.php.net/" target="_blank" rel="external">http://pecl.php.net/</a> </p>
<p>（3）SVN 下载，大多数 Pecl 扩展库也在 <a href="http://svn.php.net/viewvc/pecl/" target="_blank" rel="external">SVN</a> 中</p>
<pre><code>$ svn checkout http://svn.php.net/repository/pecl/extname/trunk extname
</code></pre></li>
<li><p>编译、安装</p>
<p>（1）通过 Pear 下载编译共享 Pecl 扩展库 extname</p>
<pre><code>$ pecl install extname

这个过程下载 extname 的源代码，编译之，并将创建 extname.so 放置于 PHP 的扩展库目录中。
</code></pre><p>（2）通过 phpize 编译共享 Pecl 扩展库 extname</p>
<pre><code>1. 下载 extname 源代码

2. 进入 extname 目录

    $ cd extname

3. 准备 PHP 扩展库的编译环境

    $ phpize

4. 编译

    $ ./configure
    $ make
    $ make install

 成功的安装并将创建 extname.so 并放置于 PHP 的扩展库目录中。
</code></pre></li>
<li><p>加载</p>
<p>（1）通过 php.ini 加载 extname.so</p>
<pre><code>1）：Windows上是加载扩展的动态链接库后缀是“.dll”，在 Unix 或 Linux 上是“.so”

2）：修改 php.ini，扩展已经在 php.ini 里。如果有 extension=extname.so 那么去掉前面“;”，或者直接添加 extension=extname.so
</code></pre></li>
<li><p>按照扩展文档方式启用扩展</p>
</li>
</ol>
<h4 id="Composer-1"><a href="#Composer-1" class="headerlink" title="Composer"></a>Composer</h4><ol>
<li><p>Composer 需要 PHP（&gt; 5.3.2）</p>
</li>
<li><p>下载 composer.phar 到当前目录</p>
<pre><code>$ curl -sS https://getcomposer.org/installer | php
</code></pre></li>
<li><p>运行 Composer</p>
<pre><code>$ php composer.phar
</code></pre></li>
<li><p>查看版本</p>
<pre><code>$ php composer.phar -V
</code></pre></li>
<li><p>下载安装包 package</p>
<pre><code>$ php composer.phar install package
</code></pre></li>
<li><p>使用安装包</p>
<p>（1）使用 autoloader 自动加载<br>因为 Composer 生成了一个 vendor/autoload.php 文件，可以直接 require/include 引入这个文件。</p>
</li>
</ol>
<h3 id="四、比较"><a href="#四、比较" class="headerlink" title="四、比较"></a>四、比较</h3><h4 id="扩展与包"><a href="#扩展与包" class="headerlink" title="扩展与包"></a>扩展与包</h4><ol>
<li><p>PHP的扩展（extension）这里应称为“模块（module）”是 C、C++ 编写的功能合集，而包（package）是 PHP 编写的功能合集</p>
</li>
<li><p>PHP的包（package）以动态链接 .dll、.so 形式加载，而包则是直接引入通过 require/include 方式加載</p>
</li>
</ol>
<p>所以，Pecl 和 Pear 是互为补充，管理者扩展与包。</p>
<h4 id="Pear-installer-与-Composer"><a href="#Pear-installer-与-Composer" class="headerlink" title="Pear installer 与 Composer"></a>Pear installer 与 Composer</h4><p>Composer 能做 Pear installer 所有的工作，并且已经取代 Pear installer。就像 Pear 官方文档里面“If you read tweets and forums you’ll get that impression that nobody uses PEAR anymore, and everyone is using composer now.”说的，表明所有人都是在使用 Composer。其中原因有二：</p>
<ol>
<li><p>Pear installer 作为系统级软件包，通常需要 root 或管理员权限。并且对于一台机器上多个项目很难使用不同版本库，但 Composer 只需你在项目根目录下修改 composer.json 文件后 update 就可以对该项目的依赖库进行版本的修改。</p>
</li>
<li><p>Pear installer 依赖关系模糊，但 Composer 有申明依赖关系的文件 composer.json（位于项目根目录下），并且还有 composer.lock（位于项目根目录下）文件类似锁文件会使任何人建立项目都将下载与指定版本完全相同的依赖，从而减轻潜在的错误对部署的影响。</p>
</li>
</ol>
<h3 id="五、使用-Composer-安装-Pear-package"><a href="#五、使用-Composer-安装-Pear-package" class="headerlink" title="五、使用 Composer 安装 Pear package"></a>五、使用 Composer 安装 Pear package</h3><p>既然 Pear installer 已经完全被 Composer 取代了，那么 Pear 库里面的一些 Pear package 我们是否也可以使用 Composer 包管理器来安装？毕竟 Pear 库有 Packagist（Composer 的包信息存储库） 没有的扩展包。所以下面介绍如何使用 Composer 来安装 Pear package。</p>
<ol>
<li><p>修改 Composer 获取包的渠道为“pear”，require 下载该渠道下的扩展包，并将 pear-pear2 作为包前缀避免冲突</p>
<pre><code>{
    &quot;repositories&quot;: [
        {
            &quot;type&quot;: &quot;pear&quot;,
            &quot;url&quot;: &quot;https://pear2.php.net&quot;
        }
    ],
    &quot;require&quot;: {
        &quot;pear-pear2.php.net/PEAR2_Text_Markdown&quot;: &quot;*&quot;,
        &quot;pear-pear2/PEAR2_HTTP_Request&quot;: &quot;*&quot;
    }
}
</code></pre></li>
<li><p>完成后，代码位于项目目录 vendor 文件夹中。应用时直接使用 autoloader 自动加载</p>
</li>
</ol>
<h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><p>如果是包使用 Composer 安装使用，如果是涉及底层扩展则使用 Pecl（也可以使用其他编译安装方式） 安装。</p>
<h3 id="七、参考资料"><a href="#七、参考资料" class="headerlink" title="七、参考资料"></a>七、参考资料</h3><ol>
<li><a href="https://www.ibm.com/developerworks/cn/linux/sdk/php/pear1/index.html" target="_blank" rel="external">PEAR简介:用PEAR来写你的下一个php程序</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-php-pecl/index.html" target="_blank" rel="external">基于 PHP5 面向对象特性的 PECL 扩展 Perl 与 PDO 编程</a></li>
<li><a href="http://php.net/manual/zh/install.pecl.php#install.pecl" target="_blank" rel="external">PECL 扩展库安装</a></li>
<li><a href="https://stackoverflow.com/questions/5409039/what-is-the-difference-between-pear-and-pear2" target="_blank" rel="external">What is the difference between PEAR and PEAR2?</a></li>
<li><a href="https://hk.saowen.com/a/5c0e71a1f917c1f76b4d5732ff0aa7e242b2d6cdcb0a17d5c36d39a221cdfb00" target="_blank" rel="external">PHP7 學習筆記</a></li>
</ol>
<p>（完）</p>
<ul>
<li>本文作者：Cindy</li>
<li>本文标题：PHP 包与扩展的管理工具Pear、Composer 与 Pecl</li>
<li>版权声明：自由转载-非商用-非衍生-保持署名（创意共享4.0许可证）</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;PHP社区提供了几个管理扩展和包的工具包括&lt;a href=&quot;http://pecl.php.net/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Pecl&lt;/a&gt;、&lt;a href=&quot;http://pear.php.net/&quot; t
    
    </summary>
    
      <category term="包与扩展管理工具" scheme="https://cindygithub2016.github.io/blog/categories/%E5%8C%85%E4%B8%8E%E6%89%A9%E5%B1%95%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Pear" scheme="https://cindygithub2016.github.io/blog/tags/Pear/"/>
    
      <category term="Composer" scheme="https://cindygithub2016.github.io/blog/tags/Composer/"/>
    
      <category term="Pecl" scheme="https://cindygithub2016.github.io/blog/tags/Pecl/"/>
    
      <category term="包管理" scheme="https://cindygithub2016.github.io/blog/tags/%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ使用</title>
    <link href="https://cindygithub2016.github.io/blog/2017/11/25/RabbitMQ%E4%BD%BF%E7%94%A8/"/>
    <id>https://cindygithub2016.github.io/blog/2017/11/25/RabbitMQ使用/</id>
    <published>2017-11-25T07:59:26.000Z</published>
    <updated>2018-05-01T13:55:17.544Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、RabbitMQ的定义"><a href="#一、RabbitMQ的定义" class="headerlink" title="一、RabbitMQ的定义"></a>一、RabbitMQ的定义</h3><p>RabbitMQ是使用erlang语言开发的开源消息队列系统，完整的实现了AMPQ（高级抽象层消息通信协议）。</p>
<h3 id="二、Mac下RabbitMQ安装"><a href="#二、Mac下RabbitMQ安装" class="headerlink" title="二、Mac下RabbitMQ安装"></a>二、Mac下RabbitMQ安装</h3><ol>
<li><p>使用Homebrew安装</p>
<pre><code>$ brew install rabbitmq
</code></pre></li>
<li><p>修改 ~/.bash_profile 配置环境变量：</p>
<pre><code># RabbitMQ Config
export PATH=$PATH:/usr/local/sbin
</code></pre></li>
<li><p>重启配置</p>
<pre><code>$ source ~/.bash_profile
</code></pre></li>
<li><p>启动mq服务（后台启动为rabbitmq-server -detached）</p>
<pre><code>$ rabbitmq-server 
</code></pre></li>
<li><p>登录管理界面 <a href="http://127.0.0.1:15672" target="_blank" rel="external">http://127.0.0.1:15672</a> 账号密码为：guest</p>
</li>
</ol>
<h3 id="三、客户端"><a href="#三、客户端" class="headerlink" title="三、客户端"></a>三、客户端</h3><p>RabbitMQ官方提供了三种PHP可用的扩展：php-amqp，php-rabbit，php-amqplib</p>
<h4 id="php-amqplib-安装"><a href="#php-amqplib-安装" class="headerlink" title="php-amqplib 安装"></a>php-amqplib 安装</h4><p>php的客户端现在常用的是php-amqplib</p>
<h5 id="（1）直接拉取github上面的代码"><a href="#（1）直接拉取github上面的代码" class="headerlink" title="（1）直接拉取github上面的代码"></a>（1）直接拉取github上面的代码</h5><pre><code>$ git clone https://github.com/php-amqplib/php-amqplib.git
</code></pre><h5 id="（2）composer安装（官网提供）"><a href="#（2）composer安装（官网提供）" class="headerlink" title="（2）composer安装（官网提供）"></a>（2）composer安装（官网提供）</h5><ol>
<li><p>将composer.json文件添加到您的项目中</p>
<pre><code>{
     “require”：{
         “php-amqplib / php-amqplib”：“&gt; = 2.6.1”
    }
}
</code></pre></li>
<li><p>下载依赖</p>
<pre><code>$ composer install
</code></pre></li>
</ol>
<h3 id="四、概念"><a href="#四、概念" class="headerlink" title="四、概念"></a>四、概念</h3><p><img src="/uploads/RabbitMQ使用/1.png" alt="图片描述"></p>
<h4 id="Virtual-vhosts"><a href="#Virtual-vhosts" class="headerlink" title="Virtual vhosts"></a>Virtual vhosts</h4><p>virtual vhosts是一个命名空间，可以存在多个exchange和queue。实现了环境（用户，用户组，exchange，queue）隔离，是权限控制的最小粒度。默认的virtual host为/。</p>
<h4 id="Exchange-交换机"><a href="#Exchange-交换机" class="headerlink" title="Exchange(交换机)"></a>Exchange(交换机)</h4><p>接受producer发送的消息，并根据binding绑定规则转发到对应的队列。默认是无名交换使用空字符串标识。exchange type(交换机类型)包含四种类型：direct，topic，headers，fanout</p>
<h5 id="（1）direct"><a href="#（1）direct" class="headerlink" title="（1）direct"></a>（1）direct</h5><p>转发消息到routigKey指定的队列</p>
<p><img src="/uploads/RabbitMQ使用/2.png" alt="图片描述"></p>
<h5 id="（2）topic"><a href="#（2）topic" class="headerlink" title="（2）topic"></a>（2）topic</h5><p>类似于direct类型，只不过routigKey为一个句点号“.”分隔的字符串</p>
<ul>
<li>可以替代一个字。</li>
</ul>
<p>＃ 可以替换零个或多个单词。</p>
<p><img src="/uploads/RabbitMQ使用/3.png" alt="图片描述"></p>
<h5 id="（3）headers"><a href="#（3）headers" class="headerlink" title="（3）headers"></a>（3）headers</h5><p>根据发送的消息内容中的headers属性进行匹配。</p>
<h5 id="（4）fanout"><a href="#（4）fanout" class="headerlink" title="（4）fanout"></a>（4）fanout</h5><p>将所有收到的消息广播到所有已知的队列。</p>
<p><img src="/uploads/RabbitMQ使用/4.png" alt="图片描述"></p>
<h4 id="Queue-消息队列"><a href="#Queue-消息队列" class="headerlink" title="Queue(消息队列)"></a>Queue(消息队列)</h4><p>queue是mq内部对象，用于存储未被customer消费的消息。相同属性的queue可以重复定义，每个消息都会被投入到一个或多个队列。</p>
<h4 id="Binding-绑定"><a href="#Binding-绑定" class="headerlink" title="Binding(绑定)"></a>Binding(绑定)</h4><p>binding是将exchange和queue按照路由规则绑定起来。可以理解为binding是exchange和queue之间的关系</p>
<h4 id="Connection（连接）"><a href="#Connection（连接）" class="headerlink" title="Connection（连接）"></a>Connection（连接）</h4><p>消息tcp连接</p>
<h4 id="Channel-信道"><a href="#Channel-信道" class="headerlink" title="Channel(信道)"></a>Channel(信道)</h4><p>每个connection里，可建立多个channel，每个channel代表一个会话任务。做到尽量共用connection</p>
<h3 id="五、RabbitMQ使用示例"><a href="#五、RabbitMQ使用示例" class="headerlink" title="五、RabbitMQ使用示例"></a>五、RabbitMQ使用示例</h3><ol>
<li><p>send.php:</p>
<pre><code>require_once __DIR__ . &apos;/vendor/autoload.php&apos;;
use PhpAmqpLib\Connection\AMQPStreamConnection;
use PhpAmqpLib\Message\AMQPMessage;

// 创建连接
$connection = new AMQPStreamConnection(&apos;localhost&apos;, 5672, &apos;guest&apos;, &apos;guest&apos;);
// 创建channel，多个channel可以共用连接
$channel = $connection-&gt;channel();

// 创建交换机以及队列（如果已经存在，不需要重新再次创建并且绑定）

// 创建直连的交换机
$channel-&gt;exchange_declare(&apos;direct_logs&apos;, &apos;direct&apos;, false, false, false);
// 创建队列
$channel-&gt;queue_declare(&apos;hello&apos;, false, false, false, false);
// 交换机跟队列的绑定，
$channel-&gt;queue_bind(&apos;hello&apos;, &apos;direct_logs&apos;, &apos;routigKey&apos;);

// 设置消息bady传送字符串logs(消息只能为字符串，建议消息均json格式)
$msg = new AMQPMessage(&apos;logs&apos;);
// 发送数据到对应的交换机direct_logs并设置对应的routigKey
$channel-&gt;basic_publish($msg, &apos;direct_logs&apos;, &apos;routigKey&apos;);
</code></pre></li>
<li><p>receive.php:</p>
<pre><code>require_once __DIR__ . &apos;/vendor/autoload.php&apos;;
use PhpAmqpLib\Connection\AMQPStreamConnection;

// 创建连接
$connection = new AMQPStreamConnection(&apos;localhost&apos;, 5672, &apos;guest&apos;, &apos;guest&apos;);
// 创建channel，多个channel可以共用连接
$channel = $connection-&gt;channel();

// 可能会在数据发布之前启动消费者，所以我们要确保队列存在，然后再尝试从中消费消息。

// 创建直连的交换机
$channel-&gt;exchange_declare(&apos;direct_logs&apos;, &apos;direct&apos;, false, false, false);
// 创建队列
$channel-&gt;queue_declare(&apos;hello&apos;, false, false, false, false);
// 交换机跟队列的绑定，
$channel-&gt;queue_bind(&apos;hello&apos;, &apos;direct_logs&apos;, &apos;routigKey&apos;);

// 回调函数
$callback = function ($msg) {
    echo $msg-&gt;body;
};

// 启动队列消费者
$channel-&gt;basic_consume(&apos;hello3&apos;, &apos;&apos;, false, true, false, false, $callback);
// 判断是否存在回调函数
while(count($channel-&gt;callbacks)) {
    // 此处为执行回调函数
    $channel-&gt;wait();
}
</code></pre></li>
</ol>
<h3 id="六、RabbitMQ备注"><a href="#六、RabbitMQ备注" class="headerlink" title="六、RabbitMQ备注"></a>六、RabbitMQ备注</h3><ol>
<li>非持久化会导致，队列重启，数据丢失</li>
<li>exchange持久化，在声明durable时参数指定为true</li>
<li>queue持久化，在声明durable时参数指定true</li>
<li>消息持久化，实例化AMQPMessage类时指定delivery_mode为2</li>
<li>exchange和queue是否持久化需要一致才能绑定</li>
<li>消费者设置手动ack，在声明no_ack参数时指定false</li>
<li>队列消息异常需要将消息删除并再次发送同样的消息置于末尾并手动记录日志</li>
</ol>
<p>（完）</p>
<ul>
<li>本文作者：Cindy</li>
<li>本文标题：Create Custom Demain Name Of Github Pages</li>
<li>版权声明：自由转载-非商用-非衍生-保持署名（创意共享4.0许可证）</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、RabbitMQ的定义&quot;&gt;&lt;a href=&quot;#一、RabbitMQ的定义&quot; class=&quot;headerlink&quot; title=&quot;一、RabbitMQ的定义&quot;&gt;&lt;/a&gt;一、RabbitMQ的定义&lt;/h3&gt;&lt;p&gt;RabbitMQ是使用erlang语言开发的开源消息
    
    </summary>
    
      <category term="RabbitMQ" scheme="https://cindygithub2016.github.io/blog/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="https://cindygithub2016.github.io/blog/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Mysql的索引详解</title>
    <link href="https://cindygithub2016.github.io/blog/2017/03/26/Mysql%E7%9A%84%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/"/>
    <id>https://cindygithub2016.github.io/blog/2017/03/26/Mysql的索引详解/</id>
    <published>2017-03-26T06:28:06.000Z</published>
    <updated>2018-05-01T13:58:17.256Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、索引的定义"><a href="#一、索引的定义" class="headerlink" title="一、索引的定义"></a>一、索引的定义</h3><p>索引(Index)是帮助Mysql高效获取数据的数据结构，即索引是<code>数据结构</code>。也就是说这些数据结构(索引)满足特定的查找算法，并且指向了数据来达到帮助Mysql高效获取数据的目的。</p>
<h3 id="二、常用的查找算法"><a href="#二、常用的查找算法" class="headerlink" title="二、常用的查找算法"></a>二、常用的查找算法</h3><p>Mysql常用的查找算法是<a href="https://zh.wikipedia.org/wiki/B%E6%A0%91" target="_blank" rel="external">B树</a>和<a href="https://zh.wikipedia.org/wiki/B%2B%E6%A0%91" target="_blank" rel="external">B+树</a></p>
<h3 id="三、B-树作为索引结构"><a href="#三、B-树作为索引结构" class="headerlink" title="三、B+树作为索引结构"></a>三、B+树作为索引结构</h3><p>索引很大，如下面一节提到的都是以索引文件形式存储在磁盘上。但是访问磁盘，我们都知道磁盘的IO操作，是机械运动，相对于内存存取要高几个量级。所以就有了将磁盘数据预读到内存中，预读的长度一般为页的整数倍。</p>
<p>根据<code>局部性原理</code>：在一段时间内，整个程序的执行所访问的存储空间局限于某个区域。所以设计者巧妙利用了局部性预读预读原理，将一个节点的大小设为等于一个页。因为根节点是常驻内存的，在根节点向下读取节点的时候，会触发一个缺页异常。此时，一次磁盘IO操作就会载入这个节点到内存。所以对于高度相对较大的二叉树就相比B树和B+树就显得不适合。</p>
<p>而B+树是B树的变种，区别在于B+树节点不存储数据，但是B树节点会存储数据。所以在查找的时候B树检索有可能在非叶子结点结束，但是B+树是只会在叶子节点结束。但是B+树叶节点两两相连可大大增加区间访问性，可使用在范围查询等，而B-树每个节点和数据在一起，则无法区间查找。而且最重要的在一次磁盘IO中，B树的每个节点都带有对应的数据，增加了节点的大小。而磁盘IO一次读出的数据量大小是固定的，单个数据变大，每次读出的就少，那么IO次数就会增多。所以从这点来看，B+树相对B-树磁盘IO次数会少。</p>
<h3 id="四、索引的存储"><a href="#四、索引的存储" class="headerlink" title="四、索引的存储"></a>四、索引的存储</h3><p>数据库必须要有索引，没有索引则检测就会变成顺序查找，时间的复杂度是O(n),在数据量很大的时候无疑是很恐怖的。在Mysql中索引是在存储引擎中实现的(上节有提到)，而不同存储引擎会使用不同索引。下面主要介绍Mysql中的InnoDB和MyISAM两种引擎。</p>
<h4 id="（1）InnoDB引擎索引的存储"><a href="#（1）InnoDB引擎索引的存储" class="headerlink" title="（1）InnoDB引擎索引的存储"></a>（1）InnoDB引擎索引的存储</h4><p>InnoDB引擎使用B+树作为索引结构。上节有提到InnoDB引擎的索引跟数据都是保存在同一个文件中。再具体点，对于InnoDB引擎的B+树主键索引结构，非叶子节点存储的是表的主键，叶子节点存储的是表的行数据。如图所示：<br><img src="/uploads/Mysql的索引详解/1.png" alt="图片描述"></p>
<p>查询<code>where id=37</code>,其中id为主键，这时候创建的主键索引如上图，这样的条件查找主键，只需要按照B+树的检索算法(红线所示)就可以找到对应的叶子节点，然后获取到行数据。而如果查询的条件为<code>where name=&#39;Cindy&#39;</code>,这时候开始查询的并不是主键而是辅助键。如图所示：</p>
<p><img src="/uploads/Mysql的索引详解/2.png" alt="图片描述"></p>
<p>这是辅助键索引B+树，是另外一棵B+树。这时候就有主键索引B+树和辅助键索引B+树，查询的时候分两步：</p>
<ol>
<li>在辅助索引B+树中检索Cindy(红线所示), 到达其叶子节点获取到对应的主键</li>
<li>获取到主键之后，在主键索引B+树中检索37，到达其叶子节点获取到对应的行数据</li>
</ol>
<p>意思就是检索完辅助索引B+树后，再检索主键索引B+树。所以InnoDB表要求必须要有主键(MyISAM可以没有)，并且最好是自增主键。如果没有设定主键或者非空唯一索引，那么MySQL自动为InnoDB表生成不可见6个字节的字段作为主键。</p>
<h4 id="（2）MyISAM引擎索引的存储"><a href="#（2）MyISAM引擎索引的存储" class="headerlink" title="（2）MyISAM引擎索引的存储"></a>（2）MyISAM引擎索引的存储</h4><p>MyISAM引擎也是使用B+树作为索引结构，只不过跟InnoDB引擎不同的地方在于，它的索引跟数据保存在不同文件中(上节有提到)。所以MyISAM引擎的主键索引B+树的叶子节点不再是保存的行数据，而是指向行数据的地址。不一样的还有辅助键索引B+树，它的叶子节点也是指向行数据的地址。对于行数据来说，两个键(主键和辅助键)无任何差别，都是直接通过B+树检索到地址。</p>
<p>也就是说MyISAM引擎通过辅助键查询的时候不需要再次访问主键索引B+树。像InnoDB引擎这样B+树的索引结构，行数据的物理存储顺序就是索引顺序的存储方式就是<code>聚簇索引</code>，像MyISAM引擎这样B+树的索引结构，行数据的物理存储顺序跟索引顺序无关的存储方式就是<code>非聚簇索引</code>，就有人会问，那么InnoDB索引存储的优势在哪？明明每次使用辅助索引检索都要经过两次B+树查找。</p>
<h3 id="五、查询比较"><a href="#五、查询比较" class="headerlink" title="五、查询比较"></a>五、查询比较</h3><ul>
<li><p>上一节有提到MyISAM适合select密集的表。在select密集的表，如果是根据主键查询，那么InnoDB引擎索引存储方式只需要检索主键索引树就可以直接拿到行数据，但是MyISAM只会拿到地址，还必须再次查找。但是如果不是主键查询，InnoDB方式会比MyISAM方式多检索一颗B+树，所以这就是为什么MyISAM适合select密集的表。</p>
</li>
<li><p>当出现行移动或者数据页分裂时辅助索引的维护工作，InnoDB方式只需要更新主键索引B+树，但是MyISAM方式则是需要更新树的地址。</p>
</li>
</ul>
<h3 id="六、聚簇索引定义"><a href="#六、聚簇索引定义" class="headerlink" title="六、聚簇索引定义"></a>六、聚簇索引定义</h3><p><code>聚簇索引</code>: 聚簇索引的顺序就是数据的物理存储顺序的存储方式。</p>
<h3 id="七、非聚簇索引定义"><a href="#七、非聚簇索引定义" class="headerlink" title="七、非聚簇索引定义"></a>七、非聚簇索引定义</h3><p><code>非聚簇索引</code>: 索引顺序与数据物理排列顺序无关的存储方式</p>
<h3 id="八、参考文献"><a href="#八、参考文献" class="headerlink" title="八、参考文献"></a>八、参考文献</h3><p><a href="http://www.codeceo.com/article/mysql-innodb-index.html" target="_blank" rel="external">MySQL的InnoDB索引原理详解</a></p>
<p>（完）</p>
<ul>
<li>本文作者：Cindy</li>
<li>本文标题：Create Custom Demain Name Of Github Pages</li>
<li>版权声明：自由转载-非商用-非衍生-保持署名（创意共享4.0许可证）</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、索引的定义&quot;&gt;&lt;a href=&quot;#一、索引的定义&quot; class=&quot;headerlink&quot; title=&quot;一、索引的定义&quot;&gt;&lt;/a&gt;一、索引的定义&lt;/h3&gt;&lt;p&gt;索引(Index)是帮助Mysql高效获取数据的数据结构，即索引是&lt;code&gt;数据结构&lt;/code&gt;
    
    </summary>
    
      <category term="Mysql教程" scheme="https://cindygithub2016.github.io/blog/categories/Mysql%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Mysql" scheme="https://cindygithub2016.github.io/blog/tags/Mysql/"/>
    
      <category term="Index" scheme="https://cindygithub2016.github.io/blog/tags/Index/"/>
    
  </entry>
  
  <entry>
    <title>Mysql的引擎详解</title>
    <link href="https://cindygithub2016.github.io/blog/2017/03/25/Mysql%E7%9A%84%E5%BC%95%E6%93%8E%E8%AF%A6%E8%A7%A3/"/>
    <id>https://cindygithub2016.github.io/blog/2017/03/25/Mysql的引擎详解/</id>
    <published>2017-03-25T10:01:13.000Z</published>
    <updated>2018-05-01T13:56:56.223Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、数据库的定义"><a href="#一、数据库的定义" class="headerlink" title="一、数据库的定义"></a>一、数据库的定义</h3><p>我们说的Mysql数据库是数据库管理系统。其中包含了数据的存储，查询，以及更新数据库中存储数据的的功能等。</p>
<h3 id="二、存储引擎的定义"><a href="#二、存储引擎的定义" class="headerlink" title="二、存储引擎的定义"></a>二、存储引擎的定义</h3><p>关系型数据库是以表的形式存储在文件或者内存中。而存储引擎可以称为操作，存储这些<code>表的类型</code>。</p>
<h3 id="三、支持的存储引擎"><a href="#三、支持的存储引擎" class="headerlink" title="三、支持的存储引擎"></a>三、支持的存储引擎</h3><pre><code>$ mysql&gt; show engines;
</code></pre><p><img src="/uploads/Mysql的引擎详解/1.png" alt="图片描述"></p>
<h3 id="四、详解InnoDB引擎"><a href="#四、详解InnoDB引擎" class="headerlink" title="四、详解InnoDB引擎"></a>四、详解InnoDB引擎</h3><p>InnoDB引擎是一个常用的事务型存储引擎。提供了事务，行级锁机制和外键约束的功能。适用于以下场合：</p>
<ol>
<li>事务</li>
<li>外键约束</li>
<li>崩溃后的灾难恢复</li>
<li>高并发，更新密集型的表</li>
<li>不支持全文索引</li>
</ol>
<p>在RUN001数据库中创建MYTABLE，MYTABLE1两张表使用InnoDB引擎，在RUN001文件夹下会生成多个文件：<br><img src="/uploads/Mysql的引擎详解/2.png" alt="图片描述"></p>
<p><code>.frm</code>结尾的文件是表结构文件</p>
<ul>
<li>[tips: 这个文件与数据库引擎无关，任何存储引擎都会去生产这个与表名同名的文件。可以用来在数据库奔溃时恢复表结构]</li>
</ul>
<p><code>.ibd</code>结尾的文件这个是单表空间文件(独立表空间)，也就是每个表使用一个表空间文件。存储该表的相关的数据，索引。</p>
<ul>
<li>[tips：如果是共享表空间，表数据和索引会保存在默认表空间文件是ibdata1(默认)中，这时候是所有表共用ibdata1(一个或者多个)文件。而bdata1文件不会在RUN001文件夹下］</li>
</ul>
<p><code>.opt</code>结尾的文件是存储改数据库下的所有表的字符集和排序规则</p>
<h3 id="五、详解MyISAM引擎"><a href="#五、详解MyISAM引擎" class="headerlink" title="五、详解MyISAM引擎"></a>五、详解MyISAM引擎</h3><p>MyISAM引擎则是不支持事务，行级锁和外键约束的。并且是强调性能，执行速度的引擎。适用于以下场合：</p>
<ol>
<li>新增密集的表，在表有读取查询的同时，支持往表中插入新纪录</li>
<li>筛选select密集的表</li>
<li>支持全文索引</li>
<li>不支持行锁，读取时对需要读到的所有表加锁，写入时则对表加排它锁</li>
</ol>
<p>在RUN001数据库中创建MYTABLE2，MYTABLE3两张表使用InnoDB引擎，在RUN001文件夹下每张表都会生成三个文件在数据库：<br><img src="/uploads/Mysql的引擎详解/3.png" alt="图片描述"></p>
<p><code>.frm</code>结尾的文件是表结构文件<br><code>.MYD</code>结尾的文件是存储数据文件<br><code>.MYI</code>结尾的文件是存储表的索引文件</p>
<p>最后总结一下，InnoDB适合inset和update密集型的表，MyISAM适合select密集的表</p>
<blockquote>
<p>提示：最后的归类总结跟引擎使用的索引有关，下节会讲到。</p>
</blockquote>
<h3 id="六、使用示例"><a href="#六、使用示例" class="headerlink" title="六、使用示例"></a>六、使用示例</h3><pre><code>$ create table MYTABLE2 (name VARCHAR(20), sex CHAR(1))ENGINE=MyISAM;
</code></pre><p>（完）</p>
<ul>
<li>本文作者：Cindy</li>
<li>本文标题：Create Custom Demain Name Of Github Pages</li>
<li>版权声明：自由转载-非商用-非衍生-保持署名（创意共享4.0许可证）</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、数据库的定义&quot;&gt;&lt;a href=&quot;#一、数据库的定义&quot; class=&quot;headerlink&quot; title=&quot;一、数据库的定义&quot;&gt;&lt;/a&gt;一、数据库的定义&lt;/h3&gt;&lt;p&gt;我们说的Mysql数据库是数据库管理系统。其中包含了数据的存储，查询，以及更新数据库中存储数
    
    </summary>
    
      <category term="Mysql教程" scheme="https://cindygithub2016.github.io/blog/categories/Mysql%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Mysql" scheme="https://cindygithub2016.github.io/blog/tags/Mysql/"/>
    
      <category term="InnoDB" scheme="https://cindygithub2016.github.io/blog/tags/InnoDB/"/>
    
      <category term="MyISAM" scheme="https://cindygithub2016.github.io/blog/tags/MyISAM/"/>
    
  </entry>
  
  <entry>
    <title>Mysql的数据类型</title>
    <link href="https://cindygithub2016.github.io/blog/2017/03/25/Mysql%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://cindygithub2016.github.io/blog/2017/03/25/Mysql的数据类型/</id>
    <published>2017-03-25T03:32:33.000Z</published>
    <updated>2018-05-01T13:58:40.154Z</updated>
    
    <content type="html"><![CDATA[<p>Mysql多种类型可以分为三类：数值、日期/时间和字符串(字符)类型。</p>
<h3 id="一、数值类型"><a href="#一、数值类型" class="headerlink" title="一、数值类型"></a>一、数值类型</h3><p>整数: tinyint、smallint、mediumint、int、bigint<br>浮点数: float、double、real、decimal</p>
<h3 id="二、日期和时间类型"><a href="#二、日期和时间类型" class="headerlink" title="二、日期和时间类型"></a>二、日期和时间类型</h3><p>date、time、datetime、timestamp、year</p>
<h3 id="三、字符串类型"><a href="#三、字符串类型" class="headerlink" title="三、字符串类型"></a>三、字符串类型</h3><p>字符串: char、varchar<br>文本: tinytext、text、mediumtext、longtext<br>二进制(可用来存储图片、音乐等): tinyblob、blob、mediumblob、longblob</p>
<p>（完）</p>
<ul>
<li>本文作者：Cindy</li>
<li>本文标题：Create Custom Demain Name Of Github Pages</li>
<li>版权声明：自由转载-非商用-非衍生-保持署名（创意共享4.0许可证）</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mysql多种类型可以分为三类：数值、日期/时间和字符串(字符)类型。&lt;/p&gt;
&lt;h3 id=&quot;一、数值类型&quot;&gt;&lt;a href=&quot;#一、数值类型&quot; class=&quot;headerlink&quot; title=&quot;一、数值类型&quot;&gt;&lt;/a&gt;一、数值类型&lt;/h3&gt;&lt;p&gt;整数: tinyint
    
    </summary>
    
      <category term="Mysql教程" scheme="https://cindygithub2016.github.io/blog/categories/Mysql%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Mysql" scheme="https://cindygithub2016.github.io/blog/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mac下Mysql的安装与卸载</title>
    <link href="https://cindygithub2016.github.io/blog/2017/03/24/Mac%E4%B8%8BMysql%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD/"/>
    <id>https://cindygithub2016.github.io/blog/2017/03/24/Mac下Mysql的安装与卸载/</id>
    <published>2017-03-24T08:25:11.000Z</published>
    <updated>2018-05-01T13:58:57.391Z</updated>
    
    <content type="html"><![CDATA[<p>用Homebrew安装Mysql,首先需要安装<a href="https://brew.sh/" target="_blank" rel="external">Homebrew</a>。</p>
<h3 id="一、安装Mysql"><a href="#一、安装Mysql" class="headerlink" title="一、安装Mysql"></a>一、安装Mysql</h3><pre><code>$ brew install mysql
</code></pre><h3 id="二、运行测试"><a href="#二、运行测试" class="headerlink" title="二、运行测试"></a>二、运行测试</h3><pre><code>$ mysql.server start
</code></pre><p>显示： </p>
<pre><code>Starting MySQL
. SUCCESS!
</code></pre><h3 id="三、登录"><a href="#三、登录" class="headerlink" title="三、登录"></a>三、登录</h3><p>默认情况下，Mysql用户root没有密码。</p>
<pre><code>$ mysql -uroot
</code></pre><p>修改密码：</p>
<pre><code>$ mysqladmin -u root password &apos;new-password&apos;
</code></pre><h3 id="四、卸载mysql"><a href="#四、卸载mysql" class="headerlink" title="四、卸载mysql"></a>四、卸载mysql</h3><pre><code>$ brew remove mysql
$ brew cleanup
</code></pre><p>如果设置了开机启动：</p>
<pre><code>$ launchctl unload -w ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist
$ rm -Rf ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist
</code></pre><p>（完）</p>
<ul>
<li>本文作者：Cindy</li>
<li>本文标题：Create Custom Demain Name Of Github Pages</li>
<li>版权声明：自由转载-非商用-非衍生-保持署名（创意共享4.0许可证）</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用Homebrew安装Mysql,首先需要安装&lt;a href=&quot;https://brew.sh/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Homebrew&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;一、安装Mysql&quot;&gt;&lt;a href=&quot;#一、安装Mysql
    
    </summary>
    
      <category term="Mysql教程" scheme="https://cindygithub2016.github.io/blog/categories/Mysql%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Mysql" scheme="https://cindygithub2016.github.io/blog/tags/Mysql/"/>
    
      <category term="Homebrew" scheme="https://cindygithub2016.github.io/blog/tags/Homebrew/"/>
    
  </entry>
  
  <entry>
    <title>Create Custom Demain Name Of Github Pages</title>
    <link href="https://cindygithub2016.github.io/blog/2017/03/18/custom-demain-name-of-github-pages/"/>
    <id>https://cindygithub2016.github.io/blog/2017/03/18/custom-demain-name-of-github-pages/</id>
    <published>2017-03-18T15:25:37.000Z</published>
    <updated>2018-05-01T13:56:13.150Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<pre><code>用自定义网址去替换username.github.io.，因为自己有这样的需求，但是在网上看到的大多都不适用，所以整理下正确的三步方法。
</code></pre></blockquote>
<p>  在<a href="https://www.gandi.net" target="_blank" rel="external">Gandi</a>购买的.me域名username.me，托管在Github Pages的域名是username.github.io。</p>
<h3 id="一、解析username-me域名到Github-pages的服务器"><a href="#一、解析username-me域名到Github-pages的服务器" class="headerlink" title="一、解析username.me域名到Github pages的服务器"></a>一、解析username.me域名到Github pages的服务器</h3><p>在Gandi的管理界面操作。打开域名详情：</p>
<p><img src="/uploads/Create-Custom-Demain-Name-Of-Github-Pages/2.png" alt="图片描述"></p>
<p>点击正在使用的版本。因为Gandi不允许你直接编辑区域文件，所以你必须创建副本，清空副本内容并去新增一条记录：</p>
<p><img src="/uploads/Create-Custom-Demain-Name-Of-Github-Pages/3.png" alt="图片描述"></p>
<p>(1) 新增类型A,代表服务器的IP指向。那么底下的值就应该填GitHub提供的地址IP：<br>192.30.252.153，而主机纪录选择@是表示username.me的解析。TTL是指域名解析的生命周期，对于固定IP的来说建议设置3600s。</p>
<p>(2) 新增一个跟(1)类似的纪录，只是将IP替换为192.30.252.154。</p>
<h3 id="二、多个域名映射"><a href="#二、多个域名映射" class="headerlink" title="二、多个域名映射"></a>二、多个域名映射</h3><p>新增类型CNAME,别名解析。那么底下的值就应该填你的Github pages的域名username.github.io. ,主机纪录选择www。TTL一样设置3600s。</p>
<p>最后点击使用此版本，并且确认使用此区域的域名是username.me。（DNS需要几个小时才能生效）</p>
<h3 id="三、隐藏username-github-io域名"><a href="#三、隐藏username-github-io域名" class="headerlink" title="三、隐藏username.github.io域名"></a>三、隐藏username.github.io域名</h3><p>  在根目录下面创建一个名为CNAME的文本文件， 里面内容为你的.me域名：<br>        $ vi CNAME</p>
<p><img src="/uploads/Create-Custom-Demain-Name-Of-Github-Pages/4.png" alt="图片描述"><br>或者直接在Github项目的setting中直接设置custom domain。</p>
<p>接着访问你的username.github.io的网址，会发现301重定向到了username.me</p>
<p><img src="/uploads/Create-Custom-Demain-Name-Of-Github-Pages/5.png" alt="图片描述"></p>
<p>总的就做完了。</p>
<hr>
<p>最后提示下，Github pages中的CNAME的文本文件起到了两个作用：<br>（1）因为username.me解析的IP是Github pages对外提供的公用IP，只是靠IP无法定位到具体page库的所以CNAME里面的域名就起到了定位的作用，所以CNAME里面无对应的域名是会报404的错误的。<br>（2）那就是我说的重定向了，username.github.io域名被隐藏，转到username.me域名了</p>
<p>（完）</p>
<ul>
<li>本文作者：Cindy</li>
<li>本文标题：Create Custom Demain Name Of Github Pages</li>
<li>版权声明：自由转载-非商用-非衍生-保持署名（创意共享4.0许可证）</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;用自定义网址去替换username.github.io.，因为自己有这样的需求，但是在网上看到的大多都不适用，所以整理下正确的三步方法。
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;  在&lt;a href=&quot;https
    
    </summary>
    
      <category term="hexo的博客搭建" scheme="https://cindygithub2016.github.io/blog/categories/hexo%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="GitHub-Pages" scheme="https://cindygithub2016.github.io/blog/tags/GitHub-Pages/"/>
    
      <category term="Gandi" scheme="https://cindygithub2016.github.io/blog/tags/Gandi/"/>
    
  </entry>
  
</feed>
